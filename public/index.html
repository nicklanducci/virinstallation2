<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Vertical Live Text x4 • OpenAI Stream + Burst Immagini</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#000; color:#fff; overflow:hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* Centra l’intero gruppo di colonne, distanza uniforme */
    .stage { position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; }
    .columns { display: flex; align-items: center; justify-content: center; gap: 6vw; }

    .viewport {
      height: 90vh; width: min(16vw, 220px);
      overflow: hidden; position: relative;
      display: flex; justify-content: center; background: #000;
    }
    /* Colonne 1 & 3: nuove parole in basso, scorrono verso l’alto */
    .viewport.mode-left  { align-items: flex-end; }
    /* Colonne 2 & 4: prima parola incollata in alto, top→down */
    .viewport.mode-spine { align-items: flex-start; }

    .line {
      writing-mode: vertical-rl;
      white-space: nowrap;
      line-height: 1.09;
      font-size: clamp(28px, 6vw, 120px);
      transform-origin: center;
      will-change: transform;
      user-select: none;
    }
    /* left: leggibile con rotazione, bottom→top */
    .line.left  { text-orientation: mixed;   transform: rotate(180deg) translateY(0); }
    /* spine: “dorso di libro”, top→down */
    .line.spine { text-orientation: sideways; transform: translateY(0); }

    /* Cursore sottile */
    .cursor { display:inline-block; width:1ch; text-align:center; animation: blink 1s step-end infinite; }
    .cursor::after { content:"▌"; }
    @keyframes blink { 50% { opacity:0; } }

    /* Overlay per burst immagini */
    .burst {
      position:absolute; inset:0; display:none; z-index:2; background:#000;
      align-items:center; justify-content:center;
    }
    .burst img {
      width:100%; height:100%; object-fit:cover; display:block; background:#111;
    }
    .burst.fallback { background:#700; }

    /* Controlli minimi */
    .controls {
      position: fixed; left: 0; right: 0; bottom: 10px;
      display: flex; gap: .5rem; justify-content: center;
      font-family: inherit;
    }
    input, button {
      background:#111; color:#fff; border:1px solid #333; border-radius:.5rem;
      padding:.6rem .8rem; font-size:16px;
    }
    button { cursor:pointer; }
  </style>
</head>
<body>
  <div class="stage">
    <div class="columns">
      <!-- Colonna 1 (left) -->
      <div class="viewport mode-left" id="viewport1">
        <div class="line left" id="line1"><span id="text1"></span><span class="cursor" id="cursor1"></span></div>
        <div class="burst" id="burst1"><img alt=""></div>
      </div>
      <!-- Colonna 2 (spine) -->
      <div class="viewport mode-spine" id="viewport2">
        <div class="line spine" id="line2"><span id="text2"></span><span class="cursor" id="cursor2"></span></div>
        <div class="burst" id="burst2"><img alt=""></div>
      </div>
      <!-- Colonna 3 (left) -->
      <div class="viewport mode-left" id="viewport3">
        <div class="line left" id="line3"><span id="text3"></span><span class="cursor" id="cursor3"></span></div>
        <div class="burst" id="burst3"><img alt=""></div>
      </div>
      <!-- Colonna 4 (spine) -->
      <div class="viewport mode-spine" id="viewport4">
        <div class="line spine" id="line4"><span id="text4"></span><span class="cursor" id="cursor4"></span></div>
        <div class="burst" id="burst4"><img alt=""></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <input id="q" placeholder="Scrivi un prompt (stesso per tutte le colonne)…" size="50" />
    <button id="go">Stream x4</button>
  </div>

  <script>
    // ========= PARAMETRI DI LETTURA =========
    const CHAR_MS=170, SPACE_MS=280, COMMA_MS=520, PERIOD_MS=1000, DASH_MS=650;
    const LEFT_BOTTOM_ROOM_PX=40;  // 1 & 3: cursore sale quasi fino in alto
    const SPINE_TOP_ROOM_PX=0;     // 2 & 4: prima parola incollata al top
    const LERP_BASE=0.06, LERP_BOOST=0.10, LAG_THRESHOLD=36;
    const REDUCED_MOTION = matchMedia("(prefers-reduced-motion: reduce)").matches;

    // ========= BURST IMMAGINI =========
    const BURST_DIR="images2";   // cartella con 1.png..96.png
    const BURST_COUNT=96;
    const BURST_MIN=20, BURST_MAX=60;
    const BURST_FRAME_MS=140;

    // Unicità cross-colonna: immagini “bloccate” finché mostrate in un burst contemporaneo
    const ACTIVE_IMAGES = new Set();
    function releaseImages(arr){ for(const n of arr) ACTIVE_IMAGES.delete(n); }

    function candidatePaths(n){
      const s2 = n.toString().padStart(2,"0");
      const ver = Date.now() + Math.random(); // cache-busting
      return [
        `${BURST_DIR}/${n}.png?v=${ver}`,
        `${BURST_DIR}/${n}.PNG?v=${ver}`,
        `${BURST_DIR}/${s2}.png?v=${ver}`,
        `${BURST_DIR}/${s2}.PNG?v=${ver}`
      ];
    }
    function loadFirstAvailable(paths){
      return new Promise((resolve,reject)=>{
        let idx=0; const img=new Image();
        img.onload=()=>resolve(img.src);
        img.onerror=()=>{ idx++; if(idx>=paths.length) reject(); else img.src=paths[idx]; };
        img.src=paths[idx];
      });
    }

    const rndInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const sleep=(ms)=>new Promise(res=>setTimeout(res,ms));
    function delayFor(ch){
      if (ch===" ") return CHAR_MS+SPACE_MS;
      if (/[,\u061B;]/.test(ch)) return CHAR_MS+COMMA_MS;
      if (/[.!?]/.test(ch))      return CHAR_MS+PERIOD_MS;
      if (/[\u2013\u2014-]/.test(ch)) return CHAR_MS+DASH_MS;
      if (ch==="\u2026") return CHAR_MS+PERIOD_MS;
      return CHAR_MS;
    }

    // ========= FABBRICA COLONNA CON STREAM =========
    function setupStreamColumn({ sid, mode, viewportId, lineId, textId, burstId }) {
      const viewport=document.getElementById(viewportId);
      const line    =document.getElementById(lineId);
      const textSpan=document.getElementById(textId);
      const burstBox=document.getElementById(burstId);
      const burstImg=burstBox.querySelector("img");

      let buffer=""; let playing=false; let es=null;
      let targetY=0, currentY=0;
      let runningScroll=false;

      function computeTargetY(){
        const contentH=line.scrollHeight;
        const viewH   =viewport.clientHeight;
        if (mode==="left"){
          const allowedH=Math.max(0, viewH-LEFT_BOTTOM_ROOM_PX);
          const excess=contentH-allowedH;
          targetY=excess>0?-excess:0; // negativo = su (post-rotazione)
        } else {
          const allowedH=Math.max(0, viewH-SPINE_TOP_ROOM_PX);
          const excess=contentH-allowedH;
          targetY=excess>0?-excess:0; // se eccede, scorri su per tenere visibile la coda
        }
      }
      function applyTransform(){
        if (mode==="left") line.style.transform=`rotate(180deg) translateY(${currentY}px)`;
        else               line.style.transform=`translateY(${currentY}px)`;
      }
      function animateScroll(){
        if (runningScroll) return;
        runningScroll=true;
        (function loop(){
          requestAnimationFrame(loop);
          if (REDUCED_MOTION) currentY=targetY;
          else {
            const lag=targetY-currentY;
            const ease=Math.abs(lag)>LAG_THRESHOLD?LERP_BOOST:LERP_BASE;
            currentY+=lag*ease;
          }
          applyTransform();
        })();
      }
      animateScroll();

      function playLoop(){
        if (playing) return;
        playing=true;
        (function step(){
          if (!buffer.length){ playing=false; return; }
          const ch=buffer[0]; buffer=buffer.slice(1);
          textSpan.textContent += (ch==="\n") ? " " : ch;
          computeTargetY();
          setTimeout(step, delayFor(ch));
        })();
      }

      function startStream(prompt){
        // reset UI
        textSpan.textContent=""; buffer=""; computeTargetY(); currentY=targetY; applyTransform();
        if (es){ try{ es.close(); }catch{} es=null; }

        // Avvia SSE (usa lo stesso prompt su 4 stream, distinguendo con sid)
        const url = `/stream?prompt=${encodeURIComponent(prompt)}&sid=${encodeURIComponent(sid)}`;
        es = new EventSource(url);

        es.addEventListener("response.output_text.delta", (e)=>{
          try {
            const msg = JSON.parse(e.data);
            if (typeof msg.delta === "string"){ buffer += msg.delta; playLoop(); }
          } catch {}
        });
        es.addEventListener("response.completed", async ()=>{
          try{ es.close(); }catch{}
          es=null;
          // Testo finito → burst → riparti con lo stesso prompt
          await runBurstGlobalUnique();
          startStream(prompt);
        });
        es.onmessage = (e)=>{
          if (e.data === "[DONE]"){ try{ es.close(); }catch{} es=null; return; }
          try{
            const msg=JSON.parse(e.data);
            if (typeof msg.delta === "string"){ buffer += msg.delta; playLoop(); }
          }catch{}
        };
        es.onerror = ()=>{
          try{ es.close(); }catch{} es=null;
          // Lascia il testo corrente; puoi ritentare dopo un attimo
          setTimeout(()=> startStream(prompt), 1200);
        };
      }

      // Burst con unicità cross-colonna (blocca numeri in ACTIVE_IMAGES durante il burst)
      async function runBurstGlobalUnique(){
        // Scegli lunghezza e un sottoinsieme di immagini non attive
        let frames = rndInt(BURST_MIN, BURST_MAX);

        // Crea un set di candidati liberi
        const free = [];
        for (let n=1; n<=BURST_COUNT; n++){ if (!ACTIVE_IMAGES.has(n)) free.push(n); }
        // Se non bastano, “libera” tutto (accettiamo potenziali collisioni rare)
        if (free.length < frames){
          // fallback: usa tutti, poi randomizza
          for (let n=1; n<=BURST_COUNT; n++) free.push(n);
        }
        // Mescola e prendi i primi “frames”
        for (let i=free.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [free[i],free[j]]=[free[j],free[i]]; }
        const chosen = free.slice(0, frames);

        // Blocca in ACTIVE mentre mostriamo
        chosen.forEach(n=> ACTIVE_IMAGES.add(n));

        burstBox.style.display="flex";
        burstBox.classList.remove("fallback");
        line.style.visibility="hidden";

        for (const n of chosen){
          try {
            const src = await loadFirstAvailable(candidatePaths(n));
            burstImg.src = src;
            burstBox.classList.remove("fallback");
          } catch {
            burstImg.removeAttribute("src");
            burstBox.classList.add("fallback");
          }
          await sleep(BURST_FRAME_MS);
        }

        burstBox.style.display="none";
        line.style.visibility="visible";
        // Rilascia immagini usate da questa colonna
        releaseImages(chosen);
      }

      return { startStream };
    }

    // ======== Istanzia 4 colonne e avvia ========
    const col1 = setupStreamColumn({ sid:"col1", mode:"left",  viewportId:"viewport1", lineId:"line1", textId:"text1", burstId:"burst1" });
    const col2 = setupStreamColumn({ sid:"col2", mode:"spine", viewportId:"viewport2", lineId:"line2", textId:"text2", burstId:"burst2" });
    const col3 = setupStreamColumn({ sid:"col3", mode:"left",  viewportId:"viewport3", lineId:"line3", textId:"text3", burstId:"burst3" });
    const col4 = setupStreamColumn({ sid:"col4", mode:"spine", viewportId:"viewport4", lineId:"line4", textId:"text4", burstId:"burst4" });

    // Prompt di default (arte concettuale, in italiano)
    const defaultPrompt = "Scrivi una singola frase forte e concettuale sull’arte, adatta a una lettura verticale, senza andare a capo.";
    const inputEl = document.getElementById("q");
    const goBtn   = document.getElementById("go");
    inputEl.value = defaultPrompt;

    function startAll(){
      const p = (inputEl.value || defaultPrompt).trim();
      col1.startStream(p);
      col2.startStream(p);
      col3.startStream(p);
      col4.startStream(p);
    }
    startAll();

    goBtn.addEventListener("click", startAll);
    inputEl.addEventListener("keydown", (e)=>{ if (e.key==="Enter") startAll(); });

    // Mantieni layout stabile su resize
    addEventListener("resize", ()=>{
      // Ogni colonna ricalcola in autonomia durante il typing/scroll
      // Qui non serve altro.
    });
  </script>
</body>
</html>
